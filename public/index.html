<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<title>Isometric Tile Puzzle (HTML + JS + Three.js)</title>
		<style>
			html,
			body {
				height: 100%;
				margin: 0;
				overflow: hidden;
				background: #0f1115;
			}
			#ui {
				position: fixed;
				left: 12px;
				top: 12px;
				color: #e8edf7;
				font-family: system-ui, -apple-system, Segoe UI, Roboto,
					sans-serif;
				background: rgba(0, 0, 0, 0.35);
				padding: 10px 12px;
				border-radius: 10px;
				backdrop-filter: blur(6px);
				user-select: none;
			}
			#toast {
				position: fixed;
				left: 50%;
				top: 24px;
				transform: translateX(-50%);
				color: #0f1115;
				font-weight: 700;
				background: #e8edf7;
				padding: 10px 14px;
				border-radius: 999px;
				display: none;
			}
		</style>
	</head>
	<body>
		<div id="ui">
			<div><b>조작</b>: 방향키 (한 칸 이동)</div>
			<div>목표: Start(초록) → Goal(노랑)</div>
		</div>
		<div id="toast">CLEAR!</div>

		<script type="module">
			import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";

			// =========================
			// 1) 레벨 데이터 (0=길, 1=벽, 2=시작, 3=골)
			// =========================
			const map = [
				[1, 1, 1, 1, 1, 1, 1],
				[1, 2, 0, 0, 0, 3, 1],
				[1, 0, 1, 1, 0, 0, 1],
				[1, 0, 0, 0, 0, 0, 1],
				[1, 1, 1, 1, 1, 1, 1],
			];

			// =========================
			// 2) Three.js 기본 세팅
			// =========================
			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0x0f1115);

			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			document.body.appendChild(renderer.domElement);

			// Lights
			const ambient = new THREE.AmbientLight(0xffffff, 0.55);
			scene.add(ambient);

			const dir = new THREE.DirectionalLight(0xffffff, 0.95);
			dir.position.set(20, 30, 10);
			dir.castShadow = true;
			dir.shadow.mapSize.set(1024, 1024);
			scene.add(dir);

			// =========================
			// 3) 아이소메트릭(직교) 카메라
			// =========================
			const aspect = window.innerWidth / window.innerHeight;
			const viewSize = 18; // 화면에 보이는 월드 크기(크면 줌아웃)
			const camera = new THREE.OrthographicCamera(
				-viewSize * aspect,
				viewSize * aspect,
				viewSize,
				-viewSize,
				0.1,
				200
			);

			// isometric-like angles
			const yaw = THREE.MathUtils.degToRad(45);
			const pitch = THREE.MathUtils.degToRad(35.264);
			const radius = 40;

			camera.position.set(
				radius * Math.cos(yaw) * Math.cos(pitch),
				radius * Math.sin(pitch),
				radius * Math.sin(yaw) * Math.cos(pitch)
			);
			camera.lookAt(0, 0, 0);
			camera.zoom = 1.25;
			camera.updateProjectionMatrix();

			// =========================
			// 4) 타일/벽 생성
			// =========================
			const TILE = 2.2;
			const WALL_H = 2.4;
			const FLOOR_H = 0.4;

			const rows = map.length;
			const cols = map[0].length;

			// 맵을 화면 중앙에 배치하기 위한 오프셋
			const offsetX = (cols - 1) * TILE * 0.5;
			const offsetZ = (rows - 1) * TILE * 0.5;

			function gridToWorld(x, y) {
				return new THREE.Vector3(
					x * TILE - offsetX,
					0,
					y * TILE - offsetZ
				);
			}

			const group = new THREE.Group();
			scene.add(group);

			const floorMat = new THREE.MeshStandardMaterial({
				color: 0x1e2430,
				roughness: 0.95,
				metalness: 0.0,
			});
			const wallMat = new THREE.MeshStandardMaterial({
				color: 0x2f394b,
				roughness: 0.95,
				metalness: 0.0,
			});

			const startMat = new THREE.MeshStandardMaterial({
				color: 0x48d597,
				roughness: 0.6,
				metalness: 0.0,
			});
			const goalMat = new THREE.MeshStandardMaterial({
				color: 0xffd35c,
				roughness: 0.6,
				metalness: 0.0,
			});

			const floorGeo = new THREE.BoxGeometry(TILE, FLOOR_H, TILE);
			const wallGeo = new THREE.BoxGeometry(TILE, WALL_H, TILE);

			let startGX = 1,
				startGY = 1;

			// Goal 오브젝트(기둥)도 하나 만들어서 눈에 잘 띄게
			const goalPillarGeo = new THREE.CylinderGeometry(
				TILE * 0.18,
				TILE * 0.18,
				2.2,
				16
			);

			let goalGX = -1,
				goalGY = -1;
			let goalMesh = null;

			for (let y = 0; y < rows; y++) {
				for (let x = 0; x < cols; x++) {
					const v = map[y][x];
					const p = gridToWorld(x, y);

					// 바닥(길/벽 상관 없이 깔아두면 보기 좋음)
					const floor = new THREE.Mesh(floorGeo, floorMat);
					floor.position.set(p.x, -FLOOR_H * 0.5, p.z);
					floor.receiveShadow = true;
					group.add(floor);

					if (v === 1) {
						const wall = new THREE.Mesh(wallGeo, wallMat);
						wall.position.set(p.x, WALL_H * 0.5, p.z);
						wall.castShadow = true;
						wall.receiveShadow = true;
						group.add(wall);
					}

					if (v === 2) {
						startGX = x;
						startGY = y;
					}
					if (v === 3) {
						goalGX = x;
						goalGY = y;
					}
				}
			}

			// Start/Goal 타일 강조(바닥 위에 얇은 타일 하나 더)
			function addMarkerTile(gx, gy, mat) {
				const p = gridToWorld(gx, gy);
				const marker = new THREE.Mesh(
					new THREE.BoxGeometry(TILE * 0.92, 0.08, TILE * 0.92),
					mat
				);
				marker.position.set(p.x, 0.05, p.z);
				marker.receiveShadow = true;
				group.add(marker);
			}

			addMarkerTile(startGX, startGY, startMat);
			addMarkerTile(goalGX, goalGY, goalMat);

			// Goal 기둥
			{
				const p = gridToWorld(goalGX, goalGY);
				goalMesh = new THREE.Mesh(goalPillarGeo, goalMat);
				goalMesh.position.set(p.x, 1.1, p.z);
				goalMesh.castShadow = true;
				group.add(goalMesh);
			}

			// =========================
			// 5) 플레이어 생성 + “한 칸 이동” 로직
			// =========================
			const playerGeo = new THREE.BoxGeometry(
				TILE * 0.45,
				1.2,
				TILE * 0.45
			);
			const playerMat = new THREE.MeshStandardMaterial({
				color: 0xe8edf7,
				roughness: 0.5,
				metalness: 0.0,
			});
			const player = new THREE.Mesh(playerGeo, playerMat);
			player.castShadow = true;
			group.add(player);

			let gridX = startGX,
				gridY = startGY;

			function snapPlayerToGrid() {
				const p = gridToWorld(gridX, gridY);
				player.position.set(p.x, 0.6, p.z);
			}
			snapPlayerToGrid();

			function canMove(nx, ny) {
				return map[ny]?.[nx] != null && map[ny][nx] !== 1;
			}

			let isMoving = false;
			let moveT = 0;
			const moveDuration = 0.18;

			const from = new THREE.Vector3();
			const to = new THREE.Vector3();

			const toast = document.getElementById("toast");
			let cleared = false;

			function easeInOut(t) {
				return t * t * (3 - 2 * t);
			}

			function tryMove(dx, dy) {
				if (cleared || isMoving) return;

				const nx = gridX + dx;
				const ny = gridY + dy;
				if (!canMove(nx, ny)) return;

				isMoving = true;
				moveT = 0;

				from.copy(player.position);
				const tp = gridToWorld(nx, ny);
				to.set(tp.x, 0.6, tp.z);

				gridX = nx;
				gridY = ny;
			}

			window.addEventListener("keydown", (e) => {
				if (e.key === "ArrowUp") tryMove(0, -1);
				if (e.key === "ArrowDown") tryMove(0, 1);
				if (e.key === "ArrowLeft") tryMove(-1, 0);
				if (e.key === "ArrowRight") tryMove(1, 0);
				if (e.key === "r" || e.key === "R") restart();
			});

			function restart() {
				cleared = false;
				toast.style.display = "none";
				gridX = startGX;
				gridY = startGY;
				isMoving = false;
				snapPlayerToGrid();
			}

			// =========================
			// 6) 루프 + 리사이즈
			// =========================
			const clock = new THREE.Clock();

			function onResize() {
				const aspect = window.innerWidth / window.innerHeight;
				camera.left = -viewSize * aspect;
				camera.right = viewSize * aspect;
				camera.top = viewSize;
				camera.bottom = -viewSize;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
			}
			window.addEventListener("resize", onResize);

			function animate() {
				requestAnimationFrame(animate);
				const dt = clock.getDelta();

				if (goalMesh) goalMesh.rotation.y += dt * 0.8;

				if (isMoving) {
					moveT += dt / moveDuration;
					const a = Math.min(moveT, 1);
					const eased = easeInOut(a);
					player.position.lerpVectors(from, to, eased);

					if (a >= 1) {
						isMoving = false;

						// 골 판정
						if (map[gridY][gridX] === 3) {
							cleared = true;
							toast.style.display = "block";
						}
					}
				}

				renderer.render(scene, camera);
			}
			animate();
		</script>
	</body>
</html>
